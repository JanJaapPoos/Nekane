y<-2003:2012
# Catch at age for the Basque fleet (FLFishery=flf), Stock data for the selected stocks (FLBiol=stk_bio),
# years, order of the species (mac, hom, hke, lez, anf),  fishmort and
# international catches for the last assessment (lez and mon in 2005, others in 2012)
load("~/Dropbox/BoB/DynState/July_2016/data/others_finAL.RData")
load("~/Dropbox/BoB/DynState/July_2016/data/FLFishery_Basque_BoB.RData")
species<- names(flf)
# Ang[[5]] and lez[[4]] in area VI equal to zero
landings.wt(flf[[4]][,,,,"VI"])[] <- 0
discards.wt(flf[[4]][,,,,"VI"])[] <- 0
landings.wt(flf[[5]][,,,,"VI"])[] <- 0
discards.wt(flf[[5]][,,,,"VI"])[] <- 0
#number_vessels[,,"PTB"] <- number_vessels[,,"PTB"] *2
#effort_days[,,"PTB"]    <- effort_days[,,"PTB"] *2
#-------------------------------------------------------------------------------
# Manipulating data for using it in the model
#-------------------------------------------------------------------------------
dimnames<-list(len=c('<MCRS','>MCRS'), year=c(2003:2012),unit=c("OTB","PTB"),
season=as.character(1:4),area=c("VI","VII","VIIIabd"))
#------------------------------------------------------------------------------
# CPUE (catch by vessel), catch weight (landings+ discards) by gear, season, year, day, vessel
#------------------------------------------------------------------------------
CPUE<-FLQuants(mac=FLQuant(, dimnames=dimnames),
hom=FLQuant(, dimnames=dimnames),
hke=FLQuant(, dimnames=dimnames),
lez=FLQuant(, dimnames=dimnames),
anf=FLQuant(, dimnames=dimnames),
others=FLQuant(, dimnames=dimnames))
for (i in 1:(length(species)+1)){
if (i<6){
catch.wt <- (landings.wt(flf[[i]])+ discards.wt(flf[[i]]))/1000
catch.wt[catch.wt==0]<- NA
units(catch.wt)<-"t"
CPUE1  <- catch.wt  %/% number_vessels[,as.character(y)]
#(effort_days[,as.character(y)] * number_vessels[,as.character(y)])#
}
if (i==6){
# Others is already in tonnes and in the proper format. <MCRS is the discard fraction,
# while >MCRS is the landing fraction for the group of species selected
CPUE1  <- others %/% number_vessels[,as.character(y)]
}
CPUE1[is.nan(CPUE1)| is.infinite(CPUE1)|CPUE1==0] <- NA
units(CPUE1)<-"t/vessel"
CPUE [[i]] <-CPUE1
}
CPUE <-   lapply(CPUE,function (x) {
units(x) <- "t/vessel"
return (x)
})
CPUE <- CPUE [-5]
# Remove the element 5 from the FLQuants --> ANGLERFISH
# Now it is considered under 'OTHERS' species
species<- names(CPUE)
#==============================================================================
## Structure for Jan Jaap's model
#==============================================================================
# Estimate the mean and the standard deviation of the time series by vessel
catchmean <-   lapply(CPUE,yearMeans)
catchmean <-   lapply(catchmean,function (x) {
quant(x) <- "cat"
units(x) <- "t/vessel"
return (x)
})
#variance divided by the number of years to estimate the variance of the mean
sigma    <-lapply(CPUE,function (x) sqrt(yearVars(x)/10))
sigma <-   lapply(sigma,function (x) {
quant(x) <- "cat"
units(x) <- "t/vessel"
return (x)
})
#==============================================================================
# DYNAMIC MODEL
#==============================================================================
library(RDynState5NAsigmaseason6Size)
#load("~/Documents/BoB/DynState/data/5spp_dynstate.RData")
mac <- hke <-  hom <- lez <- others <- new("DynStateInput")
sp<-c(mac=mac,hom=hom,hke=hke,lez=lez,others=others)
# OTB gear and PTB in area VIIIabd... for each time step a vessel chooses the gear (OTB, PTB)
# and the fishing ground based on the optimal choice given the vessel's state
#-------------------------------------------------------------------------------
dimnames<-list(len=c('<MCRS','>MCRS'),year="unique",unit="unique",
season=as.character(1:4),area=c("VIOTB","VIIOTB","VIIIabdOTB","VIIIabdPTB"))
catchmean2 <-FLQuants(mac=FLQuant(, dimnames=dimnames),
hom=FLQuant(, dimnames=dimnames),
hke=FLQuant(, dimnames=dimnames),
lez=FLQuant(, dimnames=dimnames),
others=FLQuant(, dimnames=dimnames))
sigma2 <-catchmean2
for(i in 1:5){
catchmean2 [[i]][,,,,c("VIOTB","VIIOTB","VIIIabdOTB")] <-catchmean[[i]][,,"OTB",]
catchmean2 [[i]][,,,,"VIIIabdPTB"] <-catchmean[[i]][,,"PTB",,'VIIIabd']
catchMean(sp[[i]])  <- catchmean2[[i]]
catchMean(sp[[i]])[is.na(catchMean(sp[[i]]))]<-0
catchMean(sp[[i]])[catchMean(sp[[i]])=="Inf"]<-0
catchMean(sp[[i]])[catchMean(sp[[i]])=="NaN"]<-0
catchMean(sp[[i]])<- catchMean(sp[[i]])[drop=T]
names(dimnames(catchMean(sp[[i]])))<- c('cat','season', 'option')
sigma2 [[i]][,,,,c("VIOTB","VIIOTB","VIIIabdOTB")] <-sigma[[i]][,,"OTB",]
sigma2 [[i]][,,,,"VIIIabdPTB"] <-sigma[[i]][,,"PTB",,'VIIIabd']
catchSigma(sp[[i]]) <- sigma2[[i]]
catchSigma(sp[[i]])[is.na(catchSigma(sp[[i]]))]<-0
catchSigma(sp[[i]])[catchSigma(sp[[i]])=="Inf"]<-0
catchSigma(sp[[i]])[catchSigma(sp[[i]])=="NaN"]<-0
catchSigma(sp[[i]])<- catchSigma(sp[[i]])[drop=T]
names(dimnames(catchSigma(sp[[i]])))<-c("cat","season","option")
}
mac    <- sp[[1]]
hom    <- sp[[2]]
hke    <- sp[[3]]
lez    <- sp[[4]]
others <- sp[[5]]
hke
###############################################################################
# BoB, data exploration
# Fleet dynamics
# AZTI,
# 11th July 2016
###############################################################################
#==============================================================================
# libraries
#==============================================================================
library(nekaneR)
library(plyr)
library(reshape2)
library(devtools)
library(FLCore)
library(ggplotFL)
library (FLFishery)
#==============================================================================
# Read data
#==============================================================================
y<-2003:2012
# Catch at age for the Basque fleet (FLFishery=flf), Stock data for the selected stocks (FLBiol=stk_bio),
# years, order of the species (mac, hom, hke, lez, anf),  fishmort and
# international catches for the last assessment (lez and mon in 2005, others in 2012)
load("~/Dropbox/BoB/DynState/July_2016/data/others_finAL.RData")
load("~/Dropbox/BoB/DynState/July_2016/data/FLFishery_Basque_BoB.RData")
species<- names(flf)
# Ang[[5]] and lez[[4]] in area VI equal to zero
landings.wt(flf[[4]][,,,,"VI"])[] <- 0
discards.wt(flf[[4]][,,,,"VI"])[] <- 0
landings.wt(flf[[5]][,,,,"VI"])[] <- 0
discards.wt(flf[[5]][,,,,"VI"])[] <- 0
#number_vessels[,,"PTB"] <- number_vessels[,,"PTB"] *2
#effort_days[,,"PTB"]    <- effort_days[,,"PTB"] *2
#-------------------------------------------------------------------------------
# Manipulating data for using it in the model
#-------------------------------------------------------------------------------
dimnames<-list(len=c('<MCRS','>MCRS'), year=c(2003:2012),unit=c("OTB","PTB"),
season=as.character(1:4),area=c("VI","VII","VIIIabd"))
#------------------------------------------------------------------------------
# CPUE (catch by vessel), catch weight (landings+ discards) by gear, season, year, day, vessel
#------------------------------------------------------------------------------
CPUE<-FLQuants(mac=FLQuant(, dimnames=dimnames),
hom=FLQuant(, dimnames=dimnames),
hke=FLQuant(, dimnames=dimnames),
lez=FLQuant(, dimnames=dimnames),
anf=FLQuant(, dimnames=dimnames),
others=FLQuant(, dimnames=dimnames))
for (i in 1:(length(species)+1)){
if (i<6){
catch.wt <- (landings.wt(flf[[i]])+ discards.wt(flf[[i]]))/1000
catch.wt[catch.wt==0]<- NA
units(catch.wt)<-"t"
CPUE1  <- catch.wt  %/% number_vessels[,as.character(y)]
#(effort_days[,as.character(y)] * number_vessels[,as.character(y)])#
}
if (i==6){
# Others is already in tonnes and in the proper format. <MCRS is the discard fraction,
# while >MCRS is the landing fraction for the group of species selected
CPUE1  <- others %/% number_vessels[,as.character(y)]
}
CPUE1[is.nan(CPUE1)| is.infinite(CPUE1)|CPUE1==0] <- NA
units(CPUE1)<-"t/vessel"
CPUE [[i]] <-CPUE1
}
CPUE <-   lapply(CPUE,function (x) {
units(x) <- "t/vessel"
return (x)
})
CPUE <- CPUE [-5]
# Remove the element 5 from the FLQuants --> ANGLERFISH
# Now it is considered under 'OTHERS' species
species<- names(CPUE)
#==============================================================================
## Structure for Jan Jaap's model
#==============================================================================
# Estimate the mean and the standard deviation of the time series by vessel
catchmean <-   lapply(CPUE,yearMeans)
catchmean <-   lapply(catchmean,function (x) {
quant(x) <- "cat"
units(x) <- "t/vessel"
return (x)
})
#variance divided by the number of years to estimate the variance of the mean
sigma    <-lapply(CPUE,function (x) sqrt(yearVars(x)/10))
sigma <-   lapply(sigma,function (x) {
quant(x) <- "cat"
units(x) <- "t/vessel"
return (x)
})
#==============================================================================
# DYNAMIC MODEL
#==============================================================================
library(RDynState5NAsigmaseason6Size)
#load("~/Documents/BoB/DynState/data/5spp_dynstate.RData")
mac <- hke <-  hom <- lez <- others <- new("DynStateInput")
sp<-c(mac=mac,hom=hom,hke=hke,lez=lez,others=others)
# OTB gear and PTB in area VIIIabd... for each time step a vessel chooses the gear (OTB, PTB)
# and the fishing ground based on the optimal choice given the vessel's state
#-------------------------------------------------------------------------------
dimnames<-list(len=c('<MCRS','>MCRS'),year="unique",unit="unique",
season=as.character(1:4),area=c("VIOTB","VIIOTB","VIIIabdOTB","VIIIabdPTB"))
catchmean2 <-FLQuants(mac=FLQuant(, dimnames=dimnames),
hom=FLQuant(, dimnames=dimnames),
hke=FLQuant(, dimnames=dimnames),
lez=FLQuant(, dimnames=dimnames),
others=FLQuant(, dimnames=dimnames))
sigma2 <-catchmean2
for(i in 1:5){
catchmean2 [[i]][,,,,c("VIOTB","VIIOTB","VIIIabdOTB")] <-catchmean[[i]][,,"OTB",]
catchmean2 [[i]][,,,,"VIIIabdPTB"] <-catchmean[[i]][,,"PTB",,'VIIIabd']
catchMean(sp[[i]])  <- catchmean2[[i]]
catchMean(sp[[i]])[is.na(catchMean(sp[[i]]))]<-0
catchMean(sp[[i]])[catchMean(sp[[i]])=="Inf"]<-0
catchMean(sp[[i]])[catchMean(sp[[i]])=="NaN"]<-0
catchMean(sp[[i]])<- catchMean(sp[[i]])[drop=T]
names(dimnames(catchMean(sp[[i]])))<- c('cat','season', 'option')
sigma2 [[i]][,,,,c("VIOTB","VIIOTB","VIIIabdOTB")] <-sigma[[i]][,,"OTB",]
sigma2 [[i]][,,,,"VIIIabdPTB"] <-sigma[[i]][,,"PTB",,'VIIIabd']
catchSigma(sp[[i]]) <- sigma2[[i]]
catchSigma(sp[[i]])[is.na(catchSigma(sp[[i]]))]<-0
catchSigma(sp[[i]])[catchSigma(sp[[i]])=="Inf"]<-0
catchSigma(sp[[i]])[catchSigma(sp[[i]])=="NaN"]<-0
catchSigma(sp[[i]])<- catchSigma(sp[[i]])[drop=T]
names(dimnames(catchSigma(sp[[i]])))<-c("cat","season","option")
}
mac    <- sp[[1]]
hom    <- sp[[2]]
hke    <- sp[[3]]
lez    <- sp[[4]]
others <- sp[[5]]
save(CPUE, species, flf, number_vessels,
effort_trips, effort_days, mac, hke, hom, lez, others,
file="~/Dropbox/BoB/DynState/Git/Nekane__BoB/Third version_SIGMA/data/5spp_dynstate_Inew.RData")
18*30
options(width=200)
library(RDynState5NAsigmaseason6Age)
library(ggplot2)
library(reshape2)
library(plyr)
library(scales)
setwd("~/Dropbox/BoB/MSE/Git/Nekane/complex model/")
source("functions.R")
##############################################################################
# POPULATION DYNAMICS
##############################################################################
population_dynamics <- function(pop, startyear, endyear, season, natmortality, catches, recruitment, migration){
#pop[age,year, season, area]
MigToArea <- array(0, dim=dim(migration), dimnames= dimnames(migration))
for (y in (startyear:endyear)){     # need to think this, but maybe is better change last year (y in (endy:(endy +10)))
for (ss in (1:length(season))){
# move time ---------------------
if (ss ==1){
for(age in 2:(dim(pop)[1])){
pop[age,as.character(y),as.character(ss),] <- pop[age-1,as.character(y-1),as.character(length(season)),];
}
} else {
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss-1),];
}
# birth/recruitment ---------------------
if (ss ==1){
pop[1,as.character(y),as.character(ss),] <- recruitment;
}
# natural mortality  ---------------------
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss),]*(1-natmortality)
pop[pop < 1e-20 ] <- 1e-20
# remove catches (dims of catches here is ages,season, area, just like in main )
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss),] - catches[,,as.character(ss),]
pop[pop < 1e-20 ] <- 1e-20
#migration
for (age in (1:dim(pop)[1])){
MigToArea[age,1,as.character(ss),,] <- 0
for (toarea in (dimnames(pop)[4][[1]])){
for (fromarea in (dimnames(pop)[4][[1]])){
MigToArea[age,1,as.character(ss),toarea, fromarea] <-  MigToArea[age,1,as.character(ss),toarea,fromarea] + ( pop[age,as.character(y),as.character(ss),fromarea] * migration[age,1,as.character(ss),fromarea, toarea])
}
}
for (toarea in (dimnames(pop)[4][[1]])){
for (fromarea in (dimnames(pop)[4][[1]])){
pop[age,as.character(y),as.character(ss),toarea]  <-  pop[age,as.character(y),as.character(ss),toarea] +  MigToArea[age,1,as.character(ss),toarea, fromarea]
}
}
}
}
}
return(pop)
}
##############################################################################
# YIELD CURVE
##############################################################################
yield_curve <- function(hr,lratio, wts, natmortality, R=1, sequence = seq(0.001,2,0.001), verbose=F ){
# note that definition of hr is not completely correct (should be sum over seasons, and mean over ages), but as long as consistently incorect in code it should not matter
res <- data.frame("hr"=mean(hr) *sequence,"catch"=NA, "landings"=NA)
iii <- 1
sumR <- sum(R)
if (verbose == T){
print("total Recruitment")
print(R)
}
for (ii in sequence){
respop <- yld <-  matrix(0,nrow=length(ages), ncol=length(season), dimnames=list("cat"=ages,"season"=season))
respop[1,1] <- sumR
for(aa in ages){
if (aa==1){
# respop[aa,1] <- respop[aa,1] * (1-natmortality*1)
respop[aa,1] <- respop[aa,1] * (1-(hr[aa,1]*ii))
yld[aa,1]    <- sumR   - respop[aa,1]
respop[aa,1] <- respop[aa,1] * (1-natmortality*1)
}
if (aa > 1){
respop[aa,1] <- respop[aa-1,max(season)] * (1-natmortality*0)
respop[aa,1] <- respop[aa,1]             * (1-(hr[aa,1] *ii))
yld[aa,1]    <- respop[aa-1,max(season)] - respop[aa,1]
respop[aa,1] <- respop[aa,1]             * (1-natmortality*1)
}
for (ss in 2:(max(season))){
respop[aa,ss] <- respop[aa,ss-1] * (1-natmortality*0)
respop[aa,ss] <- respop[aa,ss]   * (1-(hr[aa,ss]*ii))
yld[aa,ss]    <- respop[aa,ss-1] - respop[aa,ss]
respop[aa,ss] <- respop[aa,ss]   * (1-natmortality*1)
}
}
res[iii, ]$catch    <- sum(yld*wts)
res[iii, ]$landings <- sum(yld*lratio*wts)
iii <- iii + 1
if (verbose == T){
print("yields (in numbers)")
print(yld)
print(" ")
print("population (in numbers)")
print(respop)
}
}
return(res)
}
#SIGMAS        <- c(10, 40, 70, 100)   #SIGMA         <- 100 #comes from 2// chanheg from 300 to 200
#NVESSELS      <- c(600, 700, 800)     #SIMNUMBER     <- 600
#for (pos in NVESSELS){
#  for (sig in SIGMAS){
ages          <- 1:4
season        <- 1:6
areas         <- c("a", "b")
stab.model    <- 10
NUMRUNS       <- 80
MPstart       <- 40
SIMNUMBER     <- 700 #pos
SIGMA         <- 40 #sig
SPP1DSCSTEPS  <- 0
SPP2DSCSTEPS  <- 0
endy          <- stab.model + NUMRUNS
Linf          <- 20
K             <- 0.3
wts           <- Linf*(1-exp(-K*ages))
q             <- 0.0005
natmortality  <- 0.0001
migconstant   <- 0.2
scenario      <- "1"
sp1price      <- slope1price <- 150
sp2price      <- slope2price <- 150
# scenario I: discarding is not allowed, YPR based in C (C=L)
# scenario II: discarding is allowed, YPR based in L, hr wanted based in catches
# scenario III: discarding ocurred but not perceived, YPR based in L, hr wanted based in landings
recs1          <- c(100,0)
mig1     <- array(0, dim=c(length(ages),1,length(season),length(areas), length(areas)), dimnames=list(cat=ages,year="all",season=as.character(season), from =areas, to=areas))
mig1[,,,"a","a"] <- -migconstant
mig1[,,,"b","b"] <- -migconstant
mig1[,,,"a","b"] <- migconstant
mig1[,,,"b","a"] <- migconstant
aperm( mig1,c(1,3,2,4,5))
recs2          <- c(0,100)
mig2     <- array(0, dim=c(length(ages),1,length(season),length(areas), length(areas)), dimnames=list(cat=ages,year="all",season=as.character(season), from =areas, to=areas))
mig2[,,,"a","a"] <- -migconstant
mig2[,,,"b","b"] <- -migconstant
mig2[,,,"a","b"] <- migconstant
mig2[,,,"b","a"] <- migconstant
aperm( mig2,c(1,3,2,4,5))
effort <- array(c(1), dim=c(length(areas), length(season)), dimnames=list(option =areas,season=as.character(season)))
pop1  <- pop2         <-array(0, dim=c(length(ages),endy+1,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:(endy+1)), season=as.character(season), option =areas))
catches.n.dsvm1       <- catches.n.dsvm2       <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
landings.n.dsvm1      <- landings.n.dsvm2      <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
catches.wt.dsvm1      <- catches.wt.dsvm2      <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
landings.wt.dsvm1     <- landings.wt.dsvm2     <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
catches.wt.dsvm.tot1  <- catches.wt.dsvm.tot2  <- array(0, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
landings.wt.dsvm.tot1 <- landings.wt.dsvm.tot2 <- array(0, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
quota1                <- quota2                <- array(1.2, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
#run population for 15 year
pop1 <- population_dynamics(pop=pop1, startyear=2, endyear=stab.model, season=season, natmortality=natmortality, catches=catches.n.dsvm1[,1,,, drop=F], recruitment=recs1, migration=mig1)
pop2 <- population_dynamics(pop=pop2, startyear=2, endyear=stab.model, season=season, natmortality=natmortality, catches=catches.n.dsvm1[,1,,, drop=F], recruitment=recs2, migration=mig2)
#calculated catches can then be used for input to DSVM (has same dims as pop (1: endyr), endyr=stabmodel+numruns)
pos_catches1 <- pop1 *q*wts
pos_catches2 <- pop2 *q*wts
#set up dsvm
sp1<- sp2 <- sp3 <- sp4 <- sp5 <-    new("DynStateInput")
catchMean(sp3)  <- catchMean(sp4) <- catchMean(sp5) <- array(0.01,dim=c(length(ages),length(season),length(areas)),dimnames=list(cat=ages,season=as.character(season),option =areas))
catchSigma(sp3) <- catchSigma(sp4)<- catchSigma(sp5)<- array(0.0000001,dim=c(length(ages),length(season),length(areas)),dimnames=list(cat=ages,season=as.character(season),option =areas))
#SIZE DEPENDENT PRICING, following Zimmermann et al. (2011)
sp1Price <- array(c(sp1price+ slope1price*((wts-mean(wts)/mean(wts)))), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
sp2Price <- array(c(sp2price+ slope2price*((wts-mean(wts)/mean(wts)))), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
sp3Price <- sp4Price <- sp5Price <- array(c(0), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
#---effort and prices used (note that now c is removed (but that if other runs, then make sure to fix/remove code that removes "c" option)
control     <- DynState.control(spp1LndQuota= 200,  spp2LndQuota=200, spp1LndQuotaFine= 3e6, spp2LndQuotaFine= 3e6, fuelUse = 1, fuelPrice = 150.0, landingCosts= 0,gearMaintenance= 0, addNoFishing= TRUE, increments= 25, spp1DiscardSteps= SPP1DSCSTEPS, spp2DiscardSteps= SPP2DSCSTEPS, sigma= SIGMA, simNumber= SIMNUMBER, numThreads= 20)
#this is where our loop starts, after we set up stable population
for(yy in (stab.model):(stab.model+NUMRUNS)){
print("====== year yy ========")
print(yy)
catchMean(sp1)  <- array(apply(pos_catches1[,(yy-2):yy,,,drop=F],c(1,3,4),mean), dim=c(length(ages), length(season),length(areas)),  dimnames=list("cat"=ages,"season"= season,"option"=areas))
catchMean(sp2)  <- array(apply(pos_catches2[,(yy-2):yy,,,drop=F],c(1,3,4),mean), dim=c(length(ages), length(season),length(areas)),  dimnames=list("cat"=ages,"season"= season,"option"=areas))
# ---No way of estimating sigma, therefore we assume that is 8% of the CPUE (note slight repetion in code for dims and dimnames of 0 catch arrays for spec 3,4,5)
catchSigma(sp1) <- catchMean(sp1) *0.08
catchSigma(sp2) <- catchMean(sp2) *0.08
# if we are in MP period, then set quota based on last year
if (yy > MPstart)
control@spp1LndQuota <-  quota1[,yy,,]
#run DSVM (wiht quota constraining if in MP time)
z <- DynState(sp1, sp2, sp3, sp4, sp5, sp1Price, sp2Price, sp3Price, sp4Price, sp5Price, effort, control)
#extract DSVM results
dsvm_res <-  extract_dsvm_res (z, control, ages, season)
#Net revenuw from DSVM
economics_res             <- as.data.frame(as.matrix(netRev(z)))
names(economics_res )     <- "NetRev"
economics_res$Grossrev    <- as.data.frame(as.matrix(grossRev(z)))$V1
economics_res$Fuelcosts   <- apply(effort(sim(z)) * control(z)@fuelUse * control(z)@fuelPrice, 2, sum)
economics_res$Annualfine  <- as.data.frame(as.matrix(annualFine(z)))$V1
if (yy == stab.model){
dsvm_res_allyrs       <- cbind("year"= yy,dsvm_res)
economics_res_allyrs  <- cbind("year"= yy,economics_res)
} else {
dsvm_res_allyrs <- rbind(dsvm_res_allyrs, (cbind("year"= yy,dsvm_res)))
economics_res_allyrs <- rbind(economics_res_allyrs, (cbind("year"= yy,economics_res)))
}
#get catches in wts from DSVM
catches.wt.dsvm1[,yy,,] <- catch_dataframe_to_array(dsvm_res, ages, season, areas, "pop1", catch_option="catch.wt")
catches.wt.dsvm2[,yy,,] <- catch_dataframe_to_array(dsvm_res, ages, season, areas, "pop2", catch_option="catch.wt")
landings.wt.dsvm1[,yy,,] <- catch_dataframe_to_array(dsvm_res, ages, season, areas, "pop1", catch_option="landings.wt")
landings.wt.dsvm2[,yy,,] <- catch_dataframe_to_array(dsvm_res, ages, season, areas, "pop2", catch_option="landings.wt")
#calculate total catches (by summing over seasons and ages)
catches.wt.dsvm.tot1[] <- apply(catches.wt.dsvm1,c(2),"sum")
catches.wt.dsvm.tot2[] <- apply(catches.wt.dsvm2,c(2),"sum")
landings.wt.dsvm.tot1[] <- apply(landings.wt.dsvm1,c(2),"sum")
landings.wt.dsvm.tot2[] <- apply(landings.wt.dsvm2,c(2),"sum")
#calculate numbers caught from weight caught
catches.n.dsvm1 <- catches.wt.dsvm1/wts
catches.n.dsvm2 <- catches.wt.dsvm2/wts
landings.n.dsvm1 <- landings.wt.dsvm1/wts
landings.n.dsvm2 <- landings.wt.dsvm2/wts
# calculatae what happens to population based on catches
pop1 <- population_dynamics(pop=pop1, startyear=yy, endyear=yy+1, season=season, natmortality=natmortality, catches=catches.n.dsvm1[,yy,,,drop=F], recruitment=recs1, migration=mig1)
pop2 <- population_dynamics(pop=pop2, startyear=yy, endyear=yy+1, season=season, natmortality=natmortality, catches=catches.n.dsvm2[,yy,,,drop=F], recruitment=recs2, migration=mig2)
#calculate the catches that can be input into DSVM based on updated pop
pos_catches1 <- pop1 *q*wts
pos_catches2 <- pop2 *q*wts
#------------------------------------------
#MANAGEMENT PROCEDURE
#------------------------------------------
for(scen in (scenario)){
if (scen=="1"){
# Scenario I: no discards allowed, full avoidance of discards (landings selectivity only). Fulll avoidance of discards, this scenario contemplates the LO with landings selectivity only and fulll avoidance of discards.
#----------------
hr1 <- (apply(landings.n.dsvm1,1:3,sum)+1e-20)/ (apply(landings.n.dsvm1,1:3,sum) + apply(pop1[,1:endy,,],1:3,sum))
hr2 <- (apply(landings.n.dsvm2,1:3,sum)+1e-20)/ (apply(landings.n.dsvm2,1:3,sum) + apply(pop2[,1:endy,,],1:3,sum))
landings.ratio1 <- (apply(landings.n.dsvm1,1:3,sum)+1e-20)/ apply(catches.n.dsvm1,1:3,sum)
landings.ratio2 <- (apply(landings.n.dsvm2,1:3,sum)+1e-20)/ apply(catches.n.dsvm2,1:3,sum)
landings.ratio1[,yy,] <- landings.ratio2[,yy,] <- 1
yc1 <- yield_curve(hr=hr1[,yy,], landings.ratio1[,yy,], wts, natmortality, R=recs1, verbose=F)
yc2 <- yield_curve(hr=hr2[,yy,], landings.ratio2[,yy,], wts, natmortality, R=recs2, verbose=F)
hr1wanted <- yc1[yc1$landings==max(yc1$landings),]$hr
hr2wanted <- yc2[yc2$landings==max(yc2$landings),]$hr
}
if (scen=="2"){
# Also Scenario II: where discarding is allowed and manager only perceives LANDINGS. Landings selectivity, under this scenario the fishery is under landings selectivity, only landings contribute to yield.
#----------------
hr1 <- apply(catches.n.dsvm1,1:3,sum)/    (apply(catches.n.dsvm1,1:3,sum) +    apply(pop1[,1:endy,,],1:3,sum))
hr2 <- apply(catches.n.dsvm2,1:3,sum)/    (apply(catches.n.dsvm2,1:3,sum) +    apply(pop2[,1:endy,,],1:3,sum))
landings.ratio1 <- (apply(landings.n.dsvm1,1:3,sum)+1e-20)/ apply(catches.n.dsvm1,1:3,sum)
landings.ratio2 <- (apply(landings.n.dsvm2,1:3,sum)+1e-20)/ apply(catches.n.dsvm2,1:3,sum)
yc1 <- yield_curve(hr=hr1[,yy,], landings.ratio1[,yy,], wts, natmortality, R=recs1, verbose=F)
yc2 <- yield_curve(hr=hr2[,yy,], landings.ratio2[,yy,], wts, natmortality, R=recs2, verbose=F)
hr1wanted <- yc1[yc1$landings==max(yc1$landings),]$hr
hr2wanted <- yc2[yc2$landings==max(yc2$landings),]$hr
}
if (scen=="3"){
# Scenario III: No FULL COMPLIANCE in LO, if LO is not fully enforced, therefore, there will be the incentive to continue discarding. However the manager could think that is fully enforced and assumed that only what is landed contribute to yield.
#----------------------------
hr1 <- apply(landings.n.dsvm1,1:3,sum)/    (apply(landings.n.dsvm1,1:3,sum) +    apply(pop1[,1:endy,,],1:3,sum))
hr2 <- apply(landings.n.dsvm2,1:3,sum)/    (apply(landings.n.dsvm2,1:3,sum) +    apply(pop2[,1:endy,,],1:3,sum))
landings.ratio1 <- (apply(landings.n.dsvm1,1:3,sum)+1e-20)/ apply(catches.n.dsvm1,1:3,sum)
landings.ratio2 <- (apply(landings.n.dsvm2,1:3,sum)+1e-20)/ apply(catches.n.dsvm2,1:3,sum)
landings.ratio1[,yy,] <- landings.ratio2[,yy,] <- 1
yc1 <- yield_curve(hr=hr1[,yy,], landings.ratio1[,yy,], wts, natmortality, R=recs1, verbose=F)
yc2 <- yield_curve(hr=hr2[,yy,], landings.ratio2[,yy,], wts, natmortality, R=recs2, verbose=F)
hr1wanted <- yc1[yc1$landings==max(yc1$landings),]$hr
hr2wanted <- yc2[yc2$landings==max(yc2$landings),]$hr
}
}
#We take the first value of hr1wanted vector to guarantee that we always get a single value in case landingratio is 0
if (yy > (MPstart-1) & yy < endy){ #if (yy > (MPstart-1))
prel.quota <-  sum(sweep((hr1wanted[1]/mean(hr1[,yy,]))* hr1[,yy,]*landings.ratio1[,yy,]*apply(pop1[,yy+1,,],c(1,2), sum) ,1,wts,"*"))/SIMNUMBER
tac.constrained <- c(quota1[,yy,,]*0.85, quota1[,yy,,]*1.15)
quota1[,yy+1,,] <- max(min(prel.quota, tac.constrained[2]), tac.constrained[1])
}
}
